import { storage } from "../storage";
import { db } from "../db";
import { auditLogs, type InsertAuditLog } from "@shared/schema";
import { logger } from './logger.service';

export interface AuditLogEntry {
  action: string;
  entityType?: string;
  entityId?: string;
  userId?: string;
  metadata?: Record<string, any>;
  timestamp?: Date;
  ipAddress?: string;
  userAgent?: string;
}

export interface ErrorLogEntry {
  message: string;
  statusCode: number;
  method: string;
  path: string;
  body?: any;
  query?: any;
  ip?: string;
  userAgent?: string;
  userId?: string;
  stack?: string;
  details?: any;
}

export interface RequestLogEntry {
  requestId: string;
  timestamp: Date;
  method: string;
  path: string;
  query?: any;
  statusCode: number;
  responseTime: number;
  ip?: string;
  userAgent?: string;
  userId?: string;
  headers?: Record<string, string>;
  error?: string;
}

export interface PerformanceLogEntry {
  type: string;
  path: string;
  method: string;
  duration: number;
  threshold: number;
  userId?: string;
}

export class AuditService {
  /**
   * Log a general audit event
   */
  async logEvent(entry: AuditLogEntry): Promise<void> {
    try {
      const log: InsertAuditLog = {
        action: entry.action,
        resource: entry.entityType || 'unknown',  // Map entityType → resource
        resourceId: entry.entityId || null,       // Map entityId → resourceId
        userId: entry.userId || null,
        details: entry.metadata || {},             // Map metadata → details
        ipAddress: entry.ipAddress || null,
        userAgent: entry.userAgent || null,
        // Note: createdAt is auto-generated by database, don't set it
      };

      await db.insert(auditLogs).values(log);
    } catch (error) {
      // Log to structured logger if database logging fails
      logger.error("Failed to write audit log", { error, entry });
    }
  }

  /**
   * Log admin CRUD operations on rules
   */
  async logAdminAction(params: {
    action: "CREATE" | "UPDATE" | "DELETE" | "APPROVE" | "REJECT";
    entityType: string;
    entityId: string;
    userId: string;
    changes?: { old?: any; new?: any };
    reason?: string;
    ipAddress?: string;
  }): Promise<void> {
    await this.logEvent({
      action: `ADMIN_${params.action}`,
      entityType: params.entityType,
      entityId: params.entityId,
      userId: params.userId,
      metadata: {
        changes: params.changes,
        reason: params.reason,
        timestamp: new Date().toISOString(),
      },
      ipAddress: params.ipAddress,
    });
  }

  /**
   * Log search queries (using existing searchQueries table)
   */
  async logSearch(params: {
    query: string;
    userId?: string;
    benefitProgramId?: string;
    response?: any;
    relevanceScore?: number;
    responseTime?: number;
    searchType?: string;
  }): Promise<void> {
    try {
      await storage.createSearchQuery({
        query: params.query,
        userId: params.userId,
        benefitProgramId: params.benefitProgramId,
        response: params.response,
        relevanceScore: params.relevanceScore,
        responseTime: params.responseTime,
        searchType: params.searchType,
      });
    } catch (error) {
      logger.error("Failed to log search query", { error, params });
    }
  }

  /**
   * Log error events
   */
  async logError(entry: ErrorLogEntry): Promise<void> {
    await this.logEvent({
      action: "ERROR",
      entityType: "REQUEST",
      metadata: {
        message: entry.message,
        statusCode: entry.statusCode,
        method: entry.method,
        path: entry.path,
        query: entry.query,
        body: entry.body,
        stack: process.env.NODE_ENV === "development" ? entry.stack : undefined,
        details: entry.details,
      },
      userId: entry.userId,
      ipAddress: entry.ip,
      userAgent: entry.userAgent,
    });
  }

  /**
   * Log API requests
   */
  async logRequest(entry: RequestLogEntry): Promise<void> {
    // Only log non-successful requests or important API calls
    if (entry.statusCode >= 400 || entry.path.includes("/admin") || entry.path.includes("/auth")) {
      await this.logEvent({
        action: "API_REQUEST",
        entityType: "REQUEST",
        entityId: entry.requestId,
        metadata: {
          method: entry.method,
          path: entry.path,
          query: entry.query,
          statusCode: entry.statusCode,
          responseTime: entry.responseTime,
          headers: entry.headers,
          error: entry.error,
        },
        userId: entry.userId,
        ipAddress: entry.ip,
        userAgent: entry.userAgent,
        timestamp: entry.timestamp,
      });
    }
  }

  /**
   * Log performance issues
   */
  async logPerformance(entry: PerformanceLogEntry): Promise<void> {
    await this.logEvent({
      action: "PERFORMANCE_ISSUE",
      entityType: entry.type.toUpperCase(),
      metadata: {
        path: entry.path,
        method: entry.method,
        duration: entry.duration,
        threshold: entry.threshold,
        timestamp: new Date().toISOString(),
      },
      userId: entry.userId,
    });
  }

  /**
   * Log authentication events
   */
  async logAuth(params: {
    action: "LOGIN" | "LOGOUT" | "FAILED_LOGIN" | "PASSWORD_RESET" | "TOKEN_REFRESH";
    userId?: string;
    username?: string;
    success: boolean;
    reason?: string;
    ipAddress?: string;
    userAgent?: string;
  }): Promise<void> {
    await this.logEvent({
      action: `AUTH_${params.action}`,
      entityType: "USER",
      entityId: params.userId,
      metadata: {
        username: params.username,
        success: params.success,
        reason: params.reason,
        timestamp: new Date().toISOString(),
      },
      ipAddress: params.ipAddress,
      userAgent: params.userAgent,
    });
  }

  /**
   * Log rate limiting events
   */
  async logRateLimit(params: {
    path: string;
    method: string;
    userId?: string;
    ipAddress: string;
    limit: number;
    window: string;
  }): Promise<void> {
    await this.logEvent({
      action: "RATE_LIMIT_EXCEEDED",
      entityType: "REQUEST",
      metadata: {
        path: params.path,
        method: params.method,
        limit: params.limit,
        window: params.window,
        timestamp: new Date().toISOString(),
      },
      userId: params.userId,
      ipAddress: params.ipAddress,
    });
  }

  /**
   * Log document operations
   */
  async logDocumentAction(params: {
    action: "UPLOAD" | "PROCESS" | "VERIFY" | "DELETE" | "DOWNLOAD";
    documentId: string;
    documentName: string;
    userId?: string;
    success: boolean;
    error?: string;
    metadata?: any;
  }): Promise<void> {
    await this.logEvent({
      action: `DOCUMENT_${params.action}`,
      entityType: "DOCUMENT",
      entityId: params.documentId,
      userId: params.userId,
      metadata: {
        documentName: params.documentName,
        success: params.success,
        error: params.error,
        ...params.metadata,
        timestamp: new Date().toISOString(),
      },
    });
  }

  /**
   * Log external service interactions
   */
  async logExternalService(params: {
    service: string;
    action: string;
    success: boolean;
    responseTime?: number;
    error?: string;
    metadata?: any;
  }): Promise<void> {
    await this.logEvent({
      action: "EXTERNAL_SERVICE_CALL",
      entityType: params.service.toUpperCase(),
      metadata: {
        action: params.action,
        success: params.success,
        responseTime: params.responseTime,
        error: params.error,
        ...params.metadata,
        timestamp: new Date().toISOString(),
      },
    });
  }

  /**
   * Get recent audit logs
   */
  async getRecentLogs(params: {
    limit?: number;
    userId?: string;
    action?: string;
    entityType?: string;
    startDate?: Date;
    endDate?: Date;
  }): Promise<any[]> {
    try {
      // Query implementation would go here
      // For now, return empty array as we need to implement the storage method
      return [];
    } catch (error) {
      logger.error("Failed to retrieve audit logs", { error, params });
      return [];
    }
  }

  /**
   * Generate audit report
   */
  async generateAuditReport(params: {
    startDate: Date;
    endDate: Date;
    groupBy?: "action" | "user" | "entityType";
  }): Promise<any> {
    try {
      const logs = await this.getRecentLogs({
        startDate: params.startDate,
        endDate: params.endDate,
      });

      const report = {
        period: {
          start: params.startDate,
          end: params.endDate,
        },
        totalEvents: logs.length,
        eventsByType: {} as Record<string, number>,
        eventsByUser: {} as Record<string, number>,
        criticalEvents: logs.filter(log => 
          log.action?.includes("ERROR") || 
          log.action?.includes("FAILED") ||
          log.action?.includes("RATE_LIMIT")
        ),
      };

      // Group events
      for (const log of logs) {
        // By type
        if (log.action) {
          report.eventsByType[log.action] = (report.eventsByType[log.action] || 0) + 1;
        }
        
        // By user
        if (log.userId) {
          report.eventsByUser[log.userId] = (report.eventsByUser[log.userId] || 0) + 1;
        }
      }

      return report;
    } catch (error) {
      logger.error("Failed to generate audit report", { error, params });
      throw error;
    }
  }
}

// Export singleton instance for convenience
export const auditService = new AuditService();